<!DOCTYPE html><html><head><title>How Efficient List Operators Work in Kotlin â€” Cody Sehl </title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/app.css"><script type="text/javascript" src="/js/ga.js"></script><script type="text/javascript" src="//use.typekit.net/fjx5dfz.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script><link rel="stylesheet" href="/css/prism.css"><script type="text/javascript" src="/js/prism.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><nav><ul><li><a target="_blank" rel="noopener" href="http://codysehl.net/">About</a></li><li><a target="_blank" rel="noopener" href="http://codysehl.net/work">Work</a></li><li><a href="http://blog.codysehl.net">Blog</a></li></ul></nav></body></html><div class="blog single-post-page"><div class="sidebar"><ul><li><a href="http://blog.codysehl.net">Recent Posts</a><li><a href="http://blog.codysehl.net/tags/Software/">Software</a></li><li><a href="http://blog.codysehl.net/tags/Android/">Android</a></li><li><a href="http://blog.codysehl.net/tags/Profound-Materials/">Profound Materials</a></li><li><a href="http://blog.codysehl.net/tags/Videos/">Videos</a></li><li><a href="http://blog.codysehl.net/tags/Books/">Books</a></li><li><a href="http://blog.codysehl.net/tags/Reviews/">Reviews</a></li><li><a href="http://blog.codysehl.net/tags/Philosophy/">Philosophy</a></li><li><a href="http://blog.codysehl.net/tags/Startup-Term/">Startup Term</a></li><li><a href="http://blog.codysehl.net/tags/iOS/">iOS</a></li><li><a href="http://blog.codysehl.net/tags/Testing/">Testing</a></li><li><a href="http://blog.codysehl.net/tags/Kotlin/">Kotlin</a></li><li><a href="http://blog.codysehl.net/tags/Interviewing/">Interviewing</a></li></li></ul></div><div class="sidebar-wrap"><div class="single-post"><h2 class="header">How Efficient List Operators Work in Kotlin</h2><h3 class="date">September 1st, 2018</h3><div class="content"><p>In the previous post we took a look at whether or not Kotlin's <code>List</code> <code>map</code>, <code>filter</code>, and <code>reduce</code> operators are efficient.</p>
<p>If you haven't read that post, <a href="http://blog.codysehl.net/2018/are-kotlin-list-operators-efficient/">go ahead</a>!</p>
<p>So, we understand that they are in fact <em>not</em> efficient, where the definition of efficient means for a given list, the list is iterated over a small number of times. It turns out that using Kotlin's list operators means a list is iterated once per operator! This was the <code>A loop for every operator method</code> I described.</p>
<p>I proposed a more efficient method called <code>Many Operators, One Loop</code>. That method iterated over the list only once and transformed the list operators into an <code>if</code> statement and a series of inline operations.</p>
<h2 id="what-would-the-many-operators-one-loop-method-look-like">What would the Many Operators, One Loop method look like?</h2>
<p>In an example from the previous post, I describe a transformation: <code>.filter()</code> would become an <code>if</code>. Unfortunately, we're not writing a compiler and don't have the ability to transform one bit of code into another - any solution we come up with can only use the tools available in the language.</p>
<p>I've been thinking about this problem since I wrote the previous blog post: How <em>would</em> efficient list operators work?</p>
<p>Let's get specific about what <em>efficient</em> means:</p>
<ol type="1">
<li>Iterate over the list only once.</li>
<li>Only do work that is necessary - if a <code>map</code> comes after a <code>filter</code> that removes an element from a list, the <code>map</code> shouldn't be run.</li>
</ol>
<h2 id="how-efficient-list-operators-might-work">How efficient list operators might work</h2>
<p>Here's my guess at how efficient list operators work.</p>
<p>List operations performed on a list don't immediately execute, but instead, are saved off somewhere containing the source data and a list of <em>other</em> operations to perform. When you're ready for your data, you ask it to compute your results - maybe with a function called <code>collect</code>.</p>
<p>The <code>collect</code> function is just a loop that, for every element, applies every operation that's been saved off in sequence. Every operation can return a result or <code>null</code> (or some other empty-type value). If an operation receives a <code>null</code>, it returns immediately and does no work. At the end, all the non-null values are rounded up into a list and returned.</p>
<h2 id="how-efficient-list-operators-actually-work">How efficient list operators actually work</h2>
<p>Let's take a look at the source for <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html">Sequence</a>.</p>
<p><em>(Just as before, you probably don't want to follow the links - the files are thousands of lines long.)</em></p>
<h3 id="map">Map</h3>
<p>The <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/1.2.60/libraries/stdlib/common/src/generated/_Sequences.kt#L803">source</a> describes a function that simply returns a <code>TransformingSequence</code>, which is created by passing a source sequence and a transformation function.</p>
<p>Ok!</p>
<h4 id="transformingsequence">TransformingSequence</h4>
<p>What's a <code>TransformingSequence</code>?</p>
<p>Let's look at <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/769344569d7e6b79437221efd6d815e441dc682a/libraries/stdlib/src/kotlin/collections/Sequences.kt#L170">its implementation</a>.</p>
<p>Mostly, it's something that implements the behavior of an iterator.</p>
<pre class="lang-kotlin"><code>override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123;
  val iterator = sequence.iterator()
  override fun next(): R &#123;
    return transformer(iterator.next())
  &#125;

  override fun hasNext(): Boolean &#123;
    return iterator.hasNext()
  &#125;
&#125;</code></pre>
<p>Asking this <code>TransformingSequence</code> for its next element will cause it to ask <em>its</em> source sequence for <em>its</em> next element, then apply a given transformation function.</p>
<p>This recursive behavior could go on for a while - interesting!</p>
<h3 id="filter">Filter</h3>
<p>How about <code>Filter</code>?</p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/1.2.60/libraries/stdlib/common/src/generated/_Sequences.kt#L370">source</a> describes a function that returns a new <code>FilteringSequence</code> that takes a source sequence, a boolean value<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, and a function that takes an input and returns true or false (a <em>predicate</em>).</p>
<h4 id="filteringsequence">FilteringSequence</h4>
<p>What's a <code>FilteringSequence</code>?</p>
<p>Let's look at <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/769344569d7e6b79437221efd6d815e441dc682a/libraries/stdlib/src/kotlin/collections/Sequences.kt#L122">its implementation</a>.</p>
<pre class="lang-kotlin"><code>override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123;
  val iterator = sequence.iterator()
  var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue
  var nextItem: T? = null

  private fun calcNext() &#123;
    while (iterator.hasNext()) &#123;
      val item = iterator.next()
      if (predicate(item) == sendWhen) &#123;
        nextItem = item
        nextState = 1
        return
      &#125;
    &#125;
    nextState = 0
  &#125;

  override fun next(): T &#123;
    if (nextState == -1)
      calcNext()
    if (nextState == 0)
      throw NoSuchElementException()
    val result = nextItem
    nextItem = null
    nextState = -1
    @Suppress(&quot;UNCHECKED_CAST&quot;)
    return result as T
  &#125;

  override fun hasNext(): Boolean &#123;
    if (nextState == -1)
      calcNext()
    return nextState == 1
  &#125;
&#125;</code></pre>
<p>Take a few minutes to read that over and understand it.</p>
<p><code>FilteringSequence</code> is similar to <code>TransformingSequence</code> in that it the source sequence for a next value, but - here's where it differs! - it'll keep asking until it finds one that satisfies the given predicate! Neat!</p>
<h3 id="reduce">Reduce</h3>
<p>Finally, let's look at <code>reduce</code> and its <a target="_blank" rel="noopener" href="https://github.com/JetBrains/kotlin/blob/1.2.60/libraries/stdlib/common/src/generated/_Sequences.kt#L1272">source</a>.</p>
<pre class="lang-kotlin"><code>public inline fun &lt;S, T : S&gt; Sequence&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S &#123;
  val iterator = this.iterator()
  if (!iterator.hasNext()) throw UnsupportedOperationException(&quot;Empty sequence can&#39;t be reduced.&quot;)
  var accumulator: S = iterator.next()
  while (iterator.hasNext()) &#123;
    accumulator = operation(accumulator, iterator.next())
  &#125;
  return accumulator
&#125;</code></pre>
<p>There's no <code>ReducingSequence</code>!</p>
<p>That's because <code>reduce</code> is a <em>terminal</em> operation. A <em>terminal</em> operation is the last thing done to a Sequence. It transforms the Sequence (which is really just a bunch of potential values, yet to be computed) into actual values that are usable by the rest of a program. In the case of <code>reduce</code>, all the values in a Sequence are squashed down into one value.</p>
<p>As you can see, the implementation of <code>reduce</code> for <code>Sequence</code> looks pretty dang similar to <code>reduce</code> for <code>List</code>, which we covered in <a href="http://blog.codysehl.net/2018/are-kotlin-list-operators-efficient/#reduce">the previous post</a>:</p>
<pre class="lang-kotlin"><code>public inline fun &lt;S, T : S&gt; Array&lt;out T&gt;.reduce(operation: (acc: S, T) -&gt; S): S &#123;
  if (isEmpty())
    throw UnsupportedOperationException(&quot;Empty array can&#39;t be reduced.&quot;)
  var accumulator: S = this[0]
  for (index in 1..lastIndex) &#123;
    accumulator = operation(accumulator, this[index])
  &#125;
  return accumulator
&#125;</code></pre>
<h2 id="is-sequence-efficient">Is Sequence efficient?</h2>
<p>After looking at Kotlin's Sequence and implementations of <code>map</code>, <code>filter</code>, and <code>reduce</code> we can see that they satisfy the definition of <em>efficient</em> put forward at the beginning. The implementations above iterate through the list only once, and in the case of filter, only provide a value when the predicate is fulfilled.</p>
<p>My guess at how efficient list operators might work is a bit off from how they're actually implemented - for one, my list concept is replaced with a series of Sequences calling each other - but I think the outlines match up.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>I hope this dive into source code has shown you how fun learning the details can be!</p>
<p>Moreover, I hope you've also noticed that the guesswork solution wasn't enormously far off from the real implementation.</p>
<p>It just goes to show, everyone is capable of solving interesting problems like these, whether you're a whiz creating a programming language or a plebe who just likes to puzzle things out.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Explaining this boolean value inline seemed a bit verbose. I think the docs are clear on what role this parameter plays: <em>If <code>true</code>, values for which the predicate returns <code>true</code> are returned. Otherwise, values for which the predicate returns <code>false</code> are returned</em>.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
</ol>
</section>
</div><div id="disqus_thread"></div>
<script type="text/javascript">
	// Disqus
	
   /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
   var disqus_shortname = 'codysehl-blog'; // required: replace example with your forum shortname
   var disqus_disable_mobile = false;

   /* * * DON'T EDIT BELOW THIS LINE * * */
   (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
   })();
</script>
<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a target="_blank" rel="noopener" href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div>